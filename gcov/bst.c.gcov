        -:    0:Source:bst.c
        -:    0:Graph:bst.gcno
        -:    0:Data:bst.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "bst.h"
        -:    2:
        -:    3:#include <stdbool.h>
        -:    4:#include <stdio.h>
        -:    5:#include <stdlib.h>
        -:    6:#include <string.h>
        -:    7:
        -:    8:struct bst_t {
        -:    9:	node_t*	root;
        -:   10:	size_t	size;
        -:   11:	int	(*cmp)(const void*, const void*);
        -:   12:};
        -:   13:
        -:   14:struct node_t {
        -:   15:	void*	data;
        -:   16:	node_t*	left;
        -:   17:	node_t*	right;
        -:   18:};
        -:   19:
        -:   20:static node_t*	node_new (void* data);
        -:   21:static void	node_free (node_t*, void (*data_free)(void*));
        -:   22:
        -:   23:static void	bst_free_recursive (bst_t*, node_t*, void (*data_free)(void*));
        -:   24:static bool	bst_add_recursive (bst_t*, node_t*, void* data);
        -:   25:static size_t	bst_height_recursive (bst_t*, node_t*);
        -:   26:static void	bst_print_recursive(bst_t*, node_t*, void (*print)(void*), int);
        -:   27:
        -:   28:
        -:   29:
        -:   30:/*==============================================================================
        -:   31:	BINARY SEARCH TREE
        -:   32:==============================================================================*/
        -:   33:
function bst_new called 1 returned 100% blocks executed 100%
        1:   34:bst_t* bst_new(int (*cmp)(const void*, const void*))
        -:   35:{
        1:   36:	bst_t* bst = malloc(sizeof *bst);
        -:   37:
        1:   38:	bst->root	= NULL;
        1:   39:	bst->size	= 0;
        1:   40:	bst->cmp	= cmp;
        -:   41:
        1:   42:	return bst;
        -:   43:}
        -:   44:
function bst_free called 1 returned 100% blocks executed 100%
        1:   45:void bst_free(bst_t* bst, void (*data_free)(void*))
        -:   46:{
        1:   47:	printf("Freeing:\n");
        1:   48:	bst_free_recursive(bst, bst->root, data_free);
        1:   49:	printf("\n... done.\n\n");
        1:   50:	free(bst);
        1:   51:}
        -:   52:
function bst_free_recursive called 21 returned 100% blocks executed 100%
       21:   53:static void bst_free_recursive(	bst_t*	bst,
       21:   54:				node_t*	node,
       21:   55:				void	(*data_free)(void*))
        -:   56:{
       21:   57:	if (node == NULL)
branch  0 taken 52%
branch  1 taken 48%
       11:   58:		return;
       10:   59:	bst_free_recursive(bst, node->left, data_free);
       10:   60:	bst_free_recursive(bst, node->right, data_free);
       10:   61:	node_free(node, data_free);
       31:   62:}
        -:   63:
        -:   64:
function bst_add called 10 returned 100% blocks executed 100%
       10:   65:bool bst_add(bst_t* bst, void* data)
        -:   66:{
       10:   67:	if (bst->root == NULL) {
branch  0 taken 10%
branch  1 taken 90%
        1:   68:		bst->root = node_new(data);
        1:   69:		bst->size += 1;
        1:   70:		return true;
        -:   71:	}
        9:   72:	return bst_add_recursive(bst, bst->root, data);
       10:   73:}
        -:   74:
function bst_add_recursive called 20 returned 100% blocks executed 90%
       20:   75:static bool bst_add_recursive(bst_t* bst, node_t* node, void* data)
        -:   76:{
       20:   77:	int cmp_result = bst->cmp(data, node->data);
        -:   78:
       20:   79:	if (cmp_result == 0) {	/* Base case */
branch  0 taken 0%
branch  1 taken 100%
    #####:   80:		return false;
       20:   81:	} else if (cmp_result < 0) {
branch  0 taken 40%
branch  1 taken 60%
        8:   82:		if (node->left == NULL) {
branch  0 taken 38%
branch  1 taken 63%
        3:   83:			node->left = node_new(data);
        3:   84:			bst->size += 1;
        3:   85:			return true;
        -:   86:		} else {
        5:   87:			return bst_add_recursive(bst, node->left, data);
        -:   88:		}
        -:   89:	} else {
       12:   90:		if (node->right == NULL) {
branch  0 taken 50%
branch  1 taken 50%
        6:   91:			node->right = node_new(data);
        6:   92:			bst->size += 1;
        6:   93:			return true;
        -:   94:		} else {
        6:   95:			return bst_add_recursive(bst, node->right, data);
        -:   96:		}
        -:   97:	}
       20:   98:}
        -:   99:
function bst_size called 0 returned 0% blocks executed 0%
    #####:  100:size_t bst_size(bst_t* bst)
        -:  101:{
    #####:  102:	return bst->size;
        -:  103:}
        -:  104:
function bst_height called 1 returned 100% blocks executed 100%
        1:  105:size_t bst_height(bst_t* bst)
        -:  106:{
        1:  107:	return bst_height_recursive(bst, bst->root);
        -:  108:}
        -:  109:
        -:  110:#define MAX(A, B) ((A) > (B) ? (A) : (B))
        -:  111:
function bst_height_recursive called 124 returned 100% blocks executed 100%
      124:  112:static size_t bst_height_recursive(bst_t* bst, node_t* node)
        -:  113:{
      124:  114:	if (node == NULL) {
branch  0 taken 67%
branch  1 taken 33%
       83:  115:		return 0;
        -:  116:	} else {
      123:  117:		return 1 + MAX(	bst_height_recursive(bst, node->left),
branch  0 taken 5%
branch  1 taken 95%
        -:  118:				bst_height_recursive(bst, node->right));
        -:  119:	}
      124:  120:}
        -:  121:
        -:  122:static void
        -:  123:bst_execute_preorder_recursive  (bst_t*, node_t*, void (*execute)(void*));
        -:  124:
        -:  125:static void
        -:  126:bst_execute_inorder_recursive   (bst_t*, node_t*, void (*execute)(void*));
        -:  127:
        -:  128:static void
        -:  129:bst_execute_postorder_recursive (bst_t*, node_t*, void (*execute)(void*));
        -:  130:
        -:  131:#define BST_EXECUTE(ORDER) bst_execute_ ## ORDER ## _recursive
        -:  132:
function bst_execute called 0 returned 0% blocks executed 0%
    #####:  133:void bst_execute(bst_t*			bst,
    #####:  134:		 void			(*execute)(void* data),
    #####:  135:		 traversal_order_t	order)
        -:  136:{
    #####:  137:	switch (order) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  138:	case ORDER_PRE:	 BST_EXECUTE(preorder)	(bst, bst->root, execute);break;
    #####:  139:	case ORDER_IN:	 BST_EXECUTE(inorder)	(bst, bst->root, execute);break;
    #####:  140:	case ORDER_POST: BST_EXECUTE(postorder)	(bst, bst->root, execute);break;
        -:  141:	}
    #####:  142:}
        -:  143:
        -:  144:static void
function bst_execute_preorder_recursive called 0 returned 0% blocks executed 0%
    #####:  145:bst_execute_preorder_recursive(	bst_t*	bst,
    #####:  146:				node_t* node,
    #####:  147:				void	(*execute)(void*))
        -:  148:{
    #####:  149:	if (node == NULL)
branch  0 never executed
branch  1 never executed
    #####:  150:		return;
    #####:  151:	execute(node->data);
    #####:  152:	bst_execute_preorder_recursive(bst, node->left, execute);
    #####:  153:	bst_execute_preorder_recursive(bst, node->right, execute);
    #####:  154:}
        -:  155:
        -:  156:static void
function bst_execute_inorder_recursive called 0 returned 0% blocks executed 0%
    #####:  157:bst_execute_inorder_recursive(	bst_t*	bst,
    #####:  158:				node_t*	node,
    #####:  159:				void	(*execute)(void*))
        -:  160:{
    #####:  161:	if (node == NULL)
branch  0 never executed
branch  1 never executed
    #####:  162:		return;
    #####:  163:	bst_execute_preorder_recursive(bst, node->left, execute);
    #####:  164:	execute(node->data);
    #####:  165:	bst_execute_preorder_recursive(bst, node->right, execute);
    #####:  166:}
        -:  167:
        -:  168:static void
function bst_execute_postorder_recursive called 0 returned 0% blocks executed 0%
    #####:  169:bst_execute_postorder_recursive(bst_t*	bst,
    #####:  170:				node_t*	node,
    #####:  171:				void	(*execute)(void*))
        -:  172:{
    #####:  173:	if (node == NULL)
branch  0 never executed
branch  1 never executed
    #####:  174:		return;
    #####:  175:	bst_execute_preorder_recursive(bst, node->left, execute);
    #####:  176:	bst_execute_preorder_recursive(bst, node->right, execute);
    #####:  177:	execute(node->data);
    #####:  178:}
        -:  179:
function bst_print called 1 returned 100% blocks executed 100%
        1:  180:void bst_print(bst_t* bst, void (*print)(void* data))
        -:  181:{
        1:  182:	printf("Printing the BST:\n--------------------\n");
        1:  183:	bst_print_recursive(bst, bst->root, print, 0);
        1:  184:	printf("\n--------------------\n\n");
        1:  185:}
        -:  186:
        -:  187:static void
function bst_print_recursive called 21 returned 100% blocks executed 100%
       21:  188:bst_print_recursive(bst_t*	bst,
       21:  189:		    node_t*	node,
       21:  190:		    void	(*print)(void* data),
       21:  191:		    int		level)
        -:  192:{
      162:  193:	for (int i = 0; i < level; ++i) {
branch  0 taken 74%
branch  1 taken 26%
       60:  194:		printf("%s", i == 0 ? "|——" : "———");
       60:  195:	}
       21:  196:	if (node == NULL) {
branch  0 taken 52%
branch  1 taken 48%
       11:  197:		printf("( )\n");
       11:  198:		return;
        -:  199:	}
        -:  200:
       10:  201:	printf("(");
       10:  202:	print(node->data);
       10:  203:	printf(")\n");
       10:  204:	bst_print_recursive(bst, node->left, print, level + 1);
       10:  205:	bst_print_recursive(bst, node->right, print, level + 1);
       31:  206:}
        -:  207:
        -:  208:
        -:  209:
        -:  210:/*==============================================================================
        -:  211:	NODE
        -:  212:==============================================================================*/
        -:  213:
function node_new called 10 returned 100% blocks executed 100%
       10:  214:static node_t* node_new(void* data)
        -:  215:{
       10:  216:	node_t*	node = malloc(sizeof *node);
        -:  217:	
       10:  218:	node->data	= data;
       10:  219:	node->left	= NULL;
       10:  220:	node->right	= NULL;
        -:  221:
       10:  222:	return node;
        -:  223:}
        -:  224:
function node_free called 10 returned 100% blocks executed 100%
       10:  225:void node_free(node_t* node, void (*data_free)(void*))
        -:  226:{
       10:  227:	if (node != NULL) {
branch  0 taken 100%
branch  1 taken 0%
       10:  228:		printf(" ");
       10:  229:		data_free(node->data);
       10:  230:		free(node);
       10:  231:	}
       10:  232:}
        -:  233:
        -:  234:
        -:  235:
        -:  236:#if 0
        -:  237:static inline const void* greater(bst_t* bst, const void* a, const void* b)
        -:  238:{
        -:  239:	return bst->cmp(a, b) > 0 ? a : b;
        -:  240:}
        -:  241:#endif
        -:  242:
